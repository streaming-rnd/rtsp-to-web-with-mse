<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>웹브라우저만으로 mp4 파일 재생</title>
    <style>
        .hidden {
            display: none;
        }

        .error {
            color: red;
            margin-top: 10px;
        }
    </style>

</head>

<body>
    <h1>웹브라우저만으로 mp4 파일 재생</h1>
    <section>
        <video id="video" controls width="600"></video>
        <div id="errorMessage" class="error hidden"></div>
    </section>
    <section>
        <!-- 버튼을 추가하고 버튼을 눌렀을 때 mp4 파일을 선택할 수 있는 파일 다이얼로그를 띄운다.-->
        <button id="openFileBtn">MP4 파일 선택</button>
        <input type="file" id="fileInput" accept="video/mp4" class="hidden" />
    </section>
    <script>
        let currentVideoUrl = null;

        function playVideo(videoElement, file) {
            const url = URL.createObjectURL(file);
            videoElement.src = url;
            videoElement.play().catch(() => {
                console.error('Error playing video');
                alert('Error playing video');
            });
            return url;
        }

        function showError(message) {
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function clearError() {
            const errDiv = document.getElementById('errorMessage');
            errorMessage.classList.add('hidden');
        }

        function playVideoDirectly(videoElement, file) {
            if (currentVideoUrl) {
                URL.revokeObjectURL(currentVideoUrl);
            }
            currentVideoUrl = URL.createObjectURL(file);
            videoElement.src = currentVideoUrl;
            videoElement.play().catch(() => {
                console.error('Error playing video');
                showError('Error playing video');
            });
        }

        async function playVideoWithMSE(videoElement, file) {
            const codecs = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
            if (!window.MediaSource || !MediaSource.isTypeSupported(codecs)) {
                console.warn('MediaSource or specified codecs are not supported.');
                playVideoDirectly(videoElement, file);
                return;
            }

            try {
                const mediaSource = new MediaSource();
                if (currentVideoUrl) {
                    URL.revokeObjectURL(currentVideoUrl);
                }
                currentVideoUrl = URL.createObjectURL(mediaSource);
                videoElement.src = currentVideoUrl;

                mediaSource.addEventListener('sourceopen', async () => {
                    try {
                        const sourceBuffer = mediaSource.addSourceBuffer(codecs);
                        const arrayBuffer = await file.arrayBuffer();

                        sourceBuffer.addEventListener('error', (e) => {
                            console.error('SourceBuffer error:', e);
                            showError('SourceBuffer error occurred.');
                            playVideoDirectly(videoElement, file);
                        }, { once: true });

                        sourceBuffer.addEventListener('updateend', () => {
                            try {
                                if (mediaSource.readyState === 'open') {
                                    mediaSource.endOfStream();
                                }
                                videoElement.play().catch(() => {
                                    console.error('Error playing video');
                                    showError('Error playing video');
                                });
                            } catch (e) {
                                console.error('Error during endOfStream or play:', e);
                                showError('Error during endOfStream or play.');
                                playVideoDirectly(videoElement, file);
                            }
                        }, { once: true });
                        sourceBuffer.appendBuffer(arrayBuffer);
                    } catch (e) {
                        console.error('Error reading or appending buffer:', e);
                        showError('Error reading or appending buffer.');
                        playVideoDirectly(videoElement, file);
                    }
                }, { once: true });
            } catch (e) {
                console.error('Error clearing error message:', e);
                showError('Error initializing MediaSource.');
                playVideoDirectly(videoElement, file);
            }
        }

        function initialize() {
            const video = document.getElementById('video');
            const openFileBtn = document.getElementById('openFileBtn');
            const fileInput = document.getElementById('fileInput');

            openFileBtn.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', async (event) => {
                const file = event.target.files?.[0];
                if (!file) return;
                clearError();

                if (!file.type.startsWith('video/mp4')) {
                    showError('Selected file is not an MP4 video.');
                    return;
                }

                if (file.size > 200 * 1024 * 1024) { // 100MB 제한
                    showError('File size exceeds 100MB limit.');
                    return;
                }

                await playVideoWithMSE(video, file);
            });
        }

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>

</html>