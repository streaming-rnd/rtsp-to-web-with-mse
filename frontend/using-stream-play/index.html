<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>웹브라우저만으로 mp4 파일 재생 - 스트림 사용</title>
    <style>
        .hidden {
            display: none;
        }

        .error {
            color: red;
            margin-top: 10px;
        }
    </style>

</head>

<body>
    <h1>웹브라우저만으로 mp4 파일 재생 - 스트림 사용</h1>
    <section>
        <video id="video" controls width="600" muted></video>
        <div id="errorMessage" class="error hidden"></div>
    </section>
    <section>
        <!-- 버튼을 추가하고 버튼을 눌렀을 때 mp4 파일을 선택할 수 있는 파일 다이얼로그를 띄운다.-->
        <button id="openFileBtn">MP4 파일 선택</button>
        <input type="file" id="fileInput" accept="video/mp4" class="hidden" />
    </section>
    <script>
        let currentVideoUrl = null;

        function playVideo(videoElement, file) {
            const url = URL.createObjectURL(file);
            videoElement.src = url;
            videoElement.play().catch(() => {
                console.error('Error playing video');
                alert('Error playing video');
            });
            return url;
        }

        function showError(message) {
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function clearError() {
            const errDiv = document.getElementById('errorMessage');
            errorMessage.classList.add('hidden');
        }

        function playVideoDirectly(videoElement, file) {
            if (currentVideoUrl) {
                URL.revokeObjectURL(currentVideoUrl);
            }
            currentVideoUrl = URL.createObjectURL(file);
            videoElement.src = currentVideoUrl;
            videoElement.play().catch(() => {
                console.error('Error playing video');
                showError('Error playing video');
            });
        }

        /**
         * 지정된 시간(ms)만큼 실행을 지연시키는 Promise를 반환합니다.
         * @param {number} ms - 지연시킬 시간 (밀리초 단위)
         */
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function playVideoWithMSE(videoElement, file) {
            const codecs = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
            if (!window.MediaSource || !MediaSource.isTypeSupported(codecs)) {
                console.warn('MediaSource or specified codecs are not supported.');
                playVideoDirectly(videoElement, file);
                return;
            }

            if (currentVideoUrl) {
                URL.revokeObjectURL(currentVideoUrl);
            }

            videoElement.pause();
            videoElement.removeAttribute('src');

            const mediaSource = new MediaSource();
            currentVideoUrl = URL.createObjectURL(mediaSource);
            videoElement.src = currentVideoUrl;

            mediaSource.addEventListener('sourceopen', async () => {
                // console.log("sourceopen");
                try {
                    const sourceBuffer = mediaSource.addSourceBuffer(codecs);
                    const stream = file.stream();
                    const reader = stream.getReader();

                    const BUFFER_GOAL_SECONDS = 30; // 최소 30초 버퍼 유지
                    const MAX_BUFFER_SECONDS = 60; // 버퍼가 60초 넘으면 정리 시작
                    const CLEANUP_SECONDS = 10; // 정리 시 현재 시간 이전 30초까지 삭제 

                    let isStreamEnded = false;

                    sourceBuffer.addEventListener('error', (e) => {
                        console.error('SourceBuffer error:', e);
                        showError('SourceBuffer error occurred.');
                    });

                    const onUpdateEnd = async () => {
                        console.log("onUpdateEnd");
                        const buffered = sourceBuffer.buffered;
                        if (buffered.length > 0) {
                            const currentBufferEnd = buffered.end(0);
                            const bufferedAmount = currentBufferEnd - videoElement.currentTime;
                            console.log({ bufferedAmount });

                            if (bufferedAmount > MAX_BUFFER_SECONDS) {
                                const removeEnd = videoElement.currentTime - CLEANUP_SECONDS;
                                const removeStart = sourceBuffer.buffered.start(0);
                                console.log({ removeStart, removeEnd, currentTime: videoElement.currentTime });
                                if (removeEnd > removeStart) {
                                    console.log(`버퍼가 ${bufferedAmount.toFixed(1)}초로 너무 많아 정리합니다.`);
                                    sourceBuffer.remove(removeStart, removeEnd);
                                    // remove를 호출했으므로, 이번 사이클은 여기서 종료
                                    // remove가 끝나면 다시 updateend가 호출되어야 한다.
                                    return;
                                }
                            }
                        }

                        if (!isStreamEnded && sourceBuffer.buffered.length > 0) {
                            const bufferedAmount = sourceBuffer.buffered.end(0) - videoElement.currentTime;
                            if (bufferedAmount > BUFFER_GOAL_SECONDS) {
                                const excessBuffer = bufferedAmount - BUFFER_GOAL_SECONDS;
                                const dynamicDelay = Math.min(10000, Math.max(1000, excessBuffer * 1000)); // 1초 ~ 10초 사이
                                console.log(`버퍼가 ${bufferedAmount.toFixed(1)}초로 충분하여 ${dynamicDelay}ms 대기합니다.`);
                                await delay(dynamicDelay);
                                console.log({ end: sourceBuffer.buffered.end(0), current: videoElement.currentTime })
                                // 대기 후, 다음 작업을 위해 수동으로 fetchAndAppend 호출
                                fetchAndAppend();
                                return;
                            }
                        }

                        // 스트림이 끝났다면 모든 작업을 종료
                        if (isStreamEnded) {
                            if (mediaSource.readyState === "open" && !sourceBuffer.updating) {
                                mediaSource.endOfStream();
                            }
                            return;
                        }

                        // 버퍼가 부족하면 다음 청크 가져오기
                        fetchAndAppend();
                    }

                    sourceBuffer.addEventListener('updateend', onUpdateEnd);

                    const fetchAndAppend = async () => {
                        // console.log("start of fetchAndAppend", sourceBuffer.updating, isStreamEnded);
                        if (sourceBuffer.updating || isStreamEnded) {
                            console.log("not ready");
                            return;
                        }
                        try {
                            const { done, value } = await reader.read();
                            if (done) {
                                isStreamEnded = true;
                                onUpdateEnd();
                                return;
                            }
                            sourceBuffer.appendBuffer(value);
                        } catch (e) {
                            console.error('Error reading or appending chunk:', e);
                        }
                    }

                    // 스트리밍 시작점
                    // 첫 청크를 로드하여 즉시 재생 시작
                    fetchAndAppend();
                    videoElement.play().catch(e => {
                        console.error("Video play failed:", e);
                        showError("브라우저 정책에 의해 자동 재생이 차단되었을 수 있습니다.");
                    });
                } catch (e) {
                    console.error('Error reading or appending buffer:', e);
                    showError('Error reading or appending buffer.');
                    // playVideoDirectly(videoElement, file);
                }
            }, { once: true });
        }

        function initialize() {
            const video = document.getElementById('video');
            const openFileBtn = document.getElementById('openFileBtn');
            const fileInput = document.getElementById('fileInput');

            openFileBtn.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', async (event) => {
                const file = event.target.files?.[0];
                if (!file) return;
                clearError();

                if (!file.type.startsWith('video/mp4')) {
                    showError('Selected file is not an MP4 video.');
                    return;
                }

                if (file.size > 200 * 1024 * 1024) { // 100MB 제한
                    showError('File size exceeds 100MB limit.');
                    return;
                }

                await playVideoWithMSE(video, file);
            });
        }

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>

</html>